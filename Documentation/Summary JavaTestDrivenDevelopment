------------------------------------------------------------------------------------------------------------------------
                                                    OVERVIEW
------------------------------------------------------------------------------------------------------------------------
//----- WHAT IS JUNIT 5? -----//
 JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage

 The Junit Platform serves as a foundation for launching testing frameworks on the JVM. It also defines the TestEngine
 API for developing a testing framework that runs on the platform.
 The platform provides a Console Launcher to launch the platform from the command line and a JUnit 4 based Runner for
 running any TestEngine on the platform.

 JUnit Jupiter is the combination of the new programming model and extension model for writing tests and extensions in
 JUnit 5. The Jupiter sub-project provides a TestEngine for running Jupiter based tests on the platform.

 JUnit Vintage provides a TestEngine for running JUnit 3 and JUnit 4 based tests on the platform.

//----- SUPPORTED JAVA VERSIONS ------//
 JUnit requires Java 8 or higher at runtime.

//----- EXAMPLE PROJECT -----//
 Check out the junit5-jupiter-starter-maven project

------------------------------------------------------------------------------------------------------------------------
                                                    WRITING TESTS
------------------------------------------------------------------------------------------------------------------------
 A FIRST TEST CASE:

        import example.util.Calculator;
        import org.junit.jupiter.api.Test;
        import static org.junit.jupiter.api.Assertions.assertEquals;

        public class MyFirstJUnitJupiterTests {

            private final Calculator calculator = new Calculator();

            @Test
            void addition() {
                assertEquals(2, calculator.add(1, 1));
            }

        }

//----- ANNOTATIONS -----//
JUnit Jupiter supports the following annotations for configuring tests and extending the framework. All core annotations
are located in the org.junit.jupiter.api package in the junit-jupiter-api module.

    @Test                   Denotes that a method is a test method. Such methods are inherited unless they are overridden.

    @ParameterizedTest      Denotes that a method is a parameterized test.                              inherited

    @RepeatedTest           Denotes that a method is a test template for a repeated test.               inherited

    @TestFactory            Denotes that a method is a test factory for dynamic tests.                  inherited

    @TestTemplate           Denotes that a method is a template for test cases designed to be invoked   inherited
                            multiple times depending on the number of invocations contexts returned by
                            the registered providers.

    @TestMethodOrder        Used to configure the test method execution order for the annotated test    inherited
                            class; similar to JUnit4's @FixMethodOrder

    @TestInstance           Used to configure the test instance lifecycle for the annotated test class. inherited

    @DisplayName            Declares a custom display name for the test class or test method.           not inherited

    @DisplayNameGeneration  Declares a custom display name generator for the test class.                inherited

    @BeforeEach             Denotes that the annotated method should be executed before each @Test,     inherited
                            @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current
                            class; analogous to JUnit 4's @Before.

    @AfterEach              Denotes that the annotated method should be executed after each @Test,      inherited
                            @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current
                            class; analogous to JUnit 4's @After.

    @BeforeAll              Denotes that the annotated method should be executed before all @Test,      inherited and
                            @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current    must be static
                            class; analogous to JUnit 4's  @BeforeClass.

    @AfterAll               Denotes that het annotated method should be executed after all @Test,       inherited and
                            @RepeatedTest, @ParameterizedTest, or @TestFactory method in the current    must be static
                            class; analogous to JUnit 4's  @AfterClass.

    @Nested                 Denotes that the annotated class in a non-static nested test class.         not inherited
                            @BeforeAll and @AfterAll methods cannot be used directly in a @Nested test
                            class unless the "per-class" test instance lifecycle is used.

    @Tag                    Used to declare tags for filtering tests, either at the class of method     inherited at
                            level; analogous to test groups in TestNG or Categories in JUnit 4.         class level

    @Disabled               Used to disable a test class or test method; analogous to JUnit 4's         not inherited
                            @Ignore

    @Timeout                Used to fail a test, test factory, test template, or lifecycle method if    inherited
                            its execution exceeds a given duration.

    @ExtendWith             Used to register extensions declaratively.                                  inherited

    @RegisterExtension      Used to register extensions programmatically via fields.                    inherited

    @TempDir                Used to supply a temporary directory via field injection or parameter
                            injection in a lifecycle method or test method; located in the
                            org.junit.jupiter.api.io package.

    $$ --- Meta-Annotations and Composed Annotations ---$$
    JUnit Jupiter Annotations can be used as meta-annotations. That means that you can define your own composed
    annotation that will automatically inherit the semantics of its meta-annotations.

    EXAMPLE:
        import java.lang.annotations.ElementType;
        import java.lang.annotations.Retention;
        import java.lang.annotations.RetentionPolicy;
        import java.lang.annotations.Target;
        import org.junit.jupiter.api.Tag;

        @Target({ElementType.TYPE, ElementType.METHOD})
        @Retention(RetentionPolicy.RUNTIME)
        @Tag("fast")
        public @interface Fast {
        }

        // The following @Test method demonstrates usage of the @Fast annotation.
        @Fast
        @Test
        void myFastTest() {
            ...
        }

        // You can even take that one step further by introducing a custom @FastTest annotation that can be used as a
        // drop-in replacement for @Tag("fast") and @Test.
        import java.lang.annotations.ElementType;
        import java.lang.annotations.Retention;
        import java.lang.annotations.RetentionPolicy;
        import java.lang.annotations.Target;
        import org.junit.jupiter.api.Tag;
        import org.junit.jupiter.api.Test;

        @Target({ElementType.TYPE, ElementType.METHOD})
        @Retention(RetentionPolicy.RUNTIME)
        @Tag("fast")
        public @interface Fast {
        }

        // JUnit automatically recognizes the following as a @Test method that is tagged with "fast".
        @FastTest
        void myFastTest() {
            ...
        }

//----- TEST CLASSES AND METHODS -----//
Test Class:         any top-level class, static member class, or @Nested class that contains at least one test method.
                    test classes must be abstract and must have a single constructor.

Test Method:        any instance method that is directly annotated or meta-annotated with @Test, @RepeatedTest,
                    @ParameterizedTest, @TestFactory, or @TestTemplate.

Lifecycle Method:   any method that is directly annotated or meta-annotated with @BeforeAll, @AfterAll, @BeforeEach, or
                    @AfterEach. The methods must not be abstract and must not return a value.

Test classes, test methods and lifecycle methods are not required to be public, bu they must NOT be private.

    EXAMPLE of a standard test class: StandardTestClass.java

//----- DISPLAY NAMES -----//
Test classes and test methods can declare custom display names via @DisplayName - with spaces, special characters, and
even emojis.

    EXAMPLE: DisplayNameDemo.java

    $$--- Display Name Generators ---$$

